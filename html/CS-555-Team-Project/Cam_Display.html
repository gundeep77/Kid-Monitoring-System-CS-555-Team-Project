<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>CS-555-Team-Project.Cam_Display API documentation</title>
<meta name="description" content="This file will display our webcam footage. We must import cv2 for the display to work." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/ir-black.min.css" crossorigin>
<style>
:root {
--highlight-color: #202;
}
html {
scrollbar-face-color: #646464;
scrollbar-base-color: #646464;
scrollbar-3dlight-color: #646464;
scrollbar-highlight-color: #646464;
scrollbar-track-color: #000;
scrollbar-arrow-color: #000;
scrollbar-shadow-color: #646464;
scrollbar-dark-shadow-color: #646464;
}
::-webkit-scrollbar { width: 14px; height: 3px;}
::-webkit-scrollbar-button {
background-color: #000;
height: 3px;}
::-webkit-scrollbar-track {
background-color: #646464;}
::-webkit-scrollbar-track-piece { background-color: #000;}
::-webkit-scrollbar-thumb { height: 50px; background-color: #666; border-radius: 7px;}
::-webkit-scrollbar-corner { background-color: #646464;}
::-webkit-resizer { background-color: #666;}
.flex {
display: flex !important;
}
body {
line-height: 1.5em;
color: #fff;
background-color: #0f0f0f;
}
#content {
padding: 20px;
}
#sidebar {
padding: 30px;
overflow: hidden;
}
#sidebar>*:last-child {
margin-bottom: 2cm;
}
.http-server-breadcrumbs {
font-size: 130%;
margin: 0 0 15px 0;
}
#footer {
font-size: .75em;
padding: 5px 30px;
border-top: 1px solid #fff;
text-align: right;
}
#footer p {
margin: 0 0 0 1em;
display: inline-block;
}
#footer p:last-child {
margin-right: 30px;
}
h1,
h2,
h3,
h4,
h5 {
font-weight: 300;
color: #fff;
}
h1 {
font-size: 2.5em;
line-height: 1.1em;
}
h2 {
font-size: 1.75em;
margin: 1em 0 .50em 0;
}
h3 {
font-size: 1.4em;
margin: 25px 0 10px 0;
}
h4 {
margin: 0;
font-size: 105%;
}
h1:target,
h2:target,
h3:target,
h4:target,
h5:target,
h6:target {
background: #000;
padding: 0.2em 0;
}
a {
color: #0a0;
text-decoration: none;
transition: color .3s ease-in-out;
}
a:hover {
color: #0c0;
}
.title code {
font-weight: bold;
}
h2[id^="header-"] {
margin-top: 2em;
}
.ident {
color: #ff00ca;
}
pre code {
background: transparent;
font-size: .8em;
line-height: 1.4em;
}
code {
background: rgba(255, 255, 255, 0.1);
padding: 1px 4px;
overflow-wrap: break-word;
}
h1 code {
background: transparent
}
pre {
background: transparent;
border: 0;
border-top: 1px solid #ccc;
border-bottom: 1px solid #ccc;
margin: 1em 0;
padding: 1ex;
}
#http-server-module-list {
display: flex;
flex-flow: column;
}
#http-server-module-list div {
display: flex;
}
#http-server-module-list dt {
min-width: 10%;
}
#http-server-module-list p {
margin-top: 0;
}
.toc ul,
#index {
list-style-type: none;
margin: 0;
padding: 0;
}
#index code {
background: transparent;
}
#index h3 {
border-bottom: 1px solid #ddd;
}
#index ul {
padding: 0;
}
#index h4 {
margin-top: .6em;
font-weight: bold;
}
/* Make TOC lists have 2+ columns when viewport is wide enough.
Assuming ~20-character identifiers and ~30% wide sidebar. */
@media (min-width: 200ex) {
#index .two-column {
column-count: 2
}
}
@media (min-width: 300ex) {
#index .two-column {
column-count: 3
}
}
dl {
margin-bottom: 2em;
}
dl dl:last-child {
margin-bottom: 4em;
}
dd {
margin: 0 0 1em 3em;
}
#header-classes+dl>dd {
margin-bottom: 3em;
}
dd dd {
margin-left: 2em;
}
dd p {
margin: 10px 0;
}
.name {
background: #000;
font-weight: bold;
font-size: .85em;
padding: 5px 10px;
display: inline-block;
min-width: 40%;
}
.name:hover {
background: #0b0b0b;
}
dt:target .name {
background: var(--highlight-color);
}
.name>span:first-child {
white-space: nowrap;
}
.name.class>span:nth-child(2) {
margin-left: .4em;
}
.inherited {
color: #999;
border-left: 5px solid #eee;
padding-left: 1em;
}
.inheritance em {
font-style: normal;
font-weight: bold;
}
.pydefname {
color: #f90;
}
/* Docstrings titles, e.g. in numpydoc format */
.desc h2 {
font-weight: 400;
font-size: 1.25em;
}
.desc h3 {
font-size: 1em;
}
.desc dt code {
background: inherit;
/* Don't grey-back parameters */
}
.source summary,
.git-link-div {
color: #666;
text-align: right;
font-weight: 400;
font-size: .8em;
text-transform: uppercase;
}
.source summary>* {
white-space: nowrap;
cursor: pointer;
}
.git-link {
color: inherit;
margin-left: 1em;
}
.source pre {
max-height: 500px;
overflow: auto;
margin: 0;
}
.source pre code {
font-size: 12px;
overflow: visible;
}
.hlist {
list-style: none;
}
.hlist li {
display: inline;
}
.hlist li:after {
content: ',\2002';
}
.hlist li:last-child:after {
content: none;
}
.hlist .hlist {
display: inline;
padding-left: 1em;
}
img {
max-width: 100%;
}
td {
padding: 0 .5em;
}
.admonition {
padding: .1em .5em;
margin-bottom: 1em;
}
.admonition-title {
font-weight: bold;
}
.admonition.note,
.admonition.info,
.admonition.important {
background: #00a;
}
.admonition.todo,
.admonition.versionadded,
.admonition.tip,
.admonition.hint {
background: #050;
}
.admonition.warning,
.admonition.versionchanged,
.admonition.deprecated {
background: #ec0;
}
.admonition.error,
.admonition.danger,
.admonition.caution {
background: #c20010;
}
p {
color: #fff;
}
</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>CS-555-Team-Project.Cam_Display</code></h1>
</header>
<section id="section-intro">
<p>This file will display our webcam footage. We must import cv2 for the display to work.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This file will display our webcam footage. We must import cv2 for the display to work.&#34;&#34;&#34;
from datetime import datetime
import cv2
import tkinter.messagebox as tmsg
import os

import numpy as np
from PIL import ImageGrab


filename = str(datetime.now())+&#39;.avi&#39;
global  NUMBER
NUMBER=0


#Code to create footage storage folder to user desktop
desktop  = os.path.expanduser(&#34;~/Desktop&#34;)
today = datetime.today().strftime(&#39;%Y-%m-%d&#39;)
def createFolder(desktop):
    try:
        if not os.path.exists(desktop+&#34;/Baby Camera Footage&#34;):
            os.makedirs(desktop+&#34;/Baby Camera Footage&#34;)
        if not os.path.exists(desktop+ &#34;/Baby Camera Footage/&#34;+today):
            os.makedirs(desktop+ &#34;/Baby Camera Footage/&#34;+today)
    except OSError:
        print(&#39;Error: Creating Directory.&#39;)
    return desktop+&#34;/Baby Camera Footage/&#34;+today+&#34;/&#34;
createFolder(desktop)   

class Camera:
    &#34;&#34;&#34;
    **Description**:
    
    Camera class made to handle webcam footage.
    &#34;&#34;&#34;

    def check_cam(self, NUMBER):
        &#34;&#34;&#34;
        **Description**:
        
        Checks to see if the camera is opened or not.
        
        **Args**:

        `NUMBER` *(int)*: Takes in an integer value defined globally to capture video from indexed camera
        &#34;&#34;&#34;
        cam = cv2.VideoCapture(NUMBER) 
        if cam.isOpened():
            return True
        else:
            return False
       
    def live_feed(self, NUMBER):
        &#34;&#34;&#34;
        **Description**:
        
        Display function to show our webcam footage. No arguments are passed. To display our webcam 
        footage for our current selected camera simply pass display().
        
        **Args**:

        `NUMBER` *(int)*: Takes in an integer value defined globally to capture video from indexed camera
        &#34;&#34;&#34;
        if not self.check_cam(NUMBER):
            tmsg.showinfo(message=&#34;Cannot access camera! Please grant permission and sign in again!&#34;)
            return
        
        #this will be our initialized webcam feed starting from 0 because we only have
        #one webcam currently in service. For each successive webcam we will increment
        #the cv2.VideoCapture size.
        feed = cv2.VideoCapture(NUMBER)
        
        # image that blocks camera feed when it is disabled
        disabledpngpath = r&#39;camdisabled.png&#39;
        disabledpng = cv2.imread(disabledpngpath)
        disabledpng = cv2.resize(disabledpng, (640,480))

        disableWebcam = False
        
        # for motion detection
        frame_count = 0
        previous_frame = None
        
        #this inner function will convert the video to a standard 480p resolution across
        #all webcams that we have. Because most webcams these days on the market are a 
        #minimum of 480p this is a good standard size resolution to have.
        def make_480p(feed):
            feed.set(3,640)
            feed.set(4,480)

        make_480p(feed)
        out = cv2.VideoWriter(desktop+&#34;/Baby Camera Footage/&#34;+today+&#34;/&#34;+filename, cv2.VideoWriter_fourcc(*&#39;MJPG&#39;), 10, (640,480))
        while True:
            ret, display = feed.read()
            
            #will display our current webcam feed with the current date and time in the 
            #center of the window.
            cv2.rectangle(display, (195, 32), (427, 12), (0, 0, 0), -1)

            # time stamp font
            font = cv2.FONT_HERSHEY_SIMPLEX            
#

            img_rgb = display
            # img_rgb = cv2.cvtColor(src=img_brg, code=cv2.COLOR_BGR2RGB)

            if ((frame_count % 2) == 0):

                # 2. Prepare image; grayscale and blur
                prepared_frame = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)
                prepared_frame = cv2.GaussianBlur(src=prepared_frame, ksize=(5,5), sigmaX=0)

                # 3. Set previous frame and continue if there is None
                if (previous_frame is None):
                # First frame; there is no previous one yet
                    previous_frame = prepared_frame
                    continue

                # calculate difference and update previous frame
                diff_frame = cv2.absdiff(src1=previous_frame, src2=prepared_frame)
                previous_frame = prepared_frame

                # 4. Dilute the image a bit to make differences more seeable; more suitable for contour detection
                kernel = np.ones((5, 5))
                diff_frame = cv2.dilate(diff_frame, kernel, 1)

                # 5. Only take different areas that are different enough (&gt;20 / 255)
                # The thresh value was default 20, but I upped it to 50 so it doesn&#39;t catch every single thing that moves.
                thresh_frame = cv2.threshold(src=diff_frame, thresh=50, maxval=255, type=cv2.THRESH_BINARY)[1]

                contours, _ = cv2.findContours(image=thresh_frame, mode=cv2.RETR_EXTERNAL, method=cv2.CHAIN_APPROX_SIMPLE)
                
                # code of highlighting the contour of the detected change
                # removed for adding too much clutter
                # cv2.drawContours(image=img_rgb, contours=contours, contourIdx=-1, color=(0, 255, 0), thickness=2, lineType=cv2.LINE_AA)     

                contours, _ = cv2.findContours(image=thresh_frame, mode=cv2.RETR_EXTERNAL, method=cv2.CHAIN_APPROX_SIMPLE)
                
                # create one bounding box for all detected contours
                # xx/yy represents ending coordinates, not width/height
                (x,y,xx,yy) = (640,480,0,0)
                for contour in contours:
                    if cv2.contourArea(contour) &lt; 50:
                        # too small: skip!
                        continue
                    # find the coordinates for the one bounding box    
                    (xP, yP, wP, hP) = cv2.boundingRect(contour)
                    if (xP+wP &gt; xx):
                        (x,y,xx,yy) = (x,y,xP+wP,yy)
                    if (yP+hP &gt; yy):
                        (x,y,xx,yy) = (x,y,xx,yP+hP)                        
                    if (xP &lt; x):
                        (x,y,xx,yy) = (xP,y,xx,yy)
                    if (yP &lt; y):
                        (x,y,xx,yy) = (x,yP,xx,yy)
                
                # draw one bounding box only if it changes from default
                if ((x,y,xx,yy) != (640,480,0,0)):
                    cv2.rectangle(img=img_rgb, pt1=(x, y), pt2=(xx, yy), color=(0, 255, 0), thickness=2)

#
            cv2.putText(img_rgb ,str(datetime.now()),(210,25), font, .4,(390,255,255),1,cv2.LINE_AA)
            out.write(img_rgb)
            
            
            
            if(disableWebcam):
                cv2.imshow(&#39;Webcam &#39;+str(NUMBER+1), disabledpng)
            else:
                cv2.imshow(&#39;Webcam &#39;+str(NUMBER+1), img_rgb)
            
            #if we want to exit our display before we reach the 100 milliseconds 
            #our waitKey function is set for we can simply press the SPACEBAR and it will
            #stop our program. Ideally, we would want this to be a GUI item to 
            #close our program.
            if cv2.waitKey(100)==32:
                tmsg.showinfo(message=&#34;Recording finished! You can find the recording where your app is located.&#34;)
                break
            
            if cv2.waitKey(20)==27:
                disableWebcam = 1 - disableWebcam            
        #this will release our resource so that another program can use our camera.

        out.release()
        feed.release()
        
        #when we exit the script we can destroy the windows
        cv2.destroyAllWindows()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="CS-555-Team-Project.Cam_Display.createFolder"><code class="name flex">
<span>def <span class="ident">createFolder</span></span>(<span>desktop)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createFolder(desktop):
    try:
        if not os.path.exists(desktop+&#34;/Baby Camera Footage&#34;):
            os.makedirs(desktop+&#34;/Baby Camera Footage&#34;)
        if not os.path.exists(desktop+ &#34;/Baby Camera Footage/&#34;+today):
            os.makedirs(desktop+ &#34;/Baby Camera Footage/&#34;+today)
    except OSError:
        print(&#39;Error: Creating Directory.&#39;)
    return desktop+&#34;/Baby Camera Footage/&#34;+today+&#34;/&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="CS-555-Team-Project.Cam_Display.Camera"><code class="flex name class">
<span>class <span class="ident">Camera</span></span>
</code></dt>
<dd>
<div class="desc"><p><strong>Description</strong>:</p>
<p>Camera class made to handle webcam footage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Camera:
    &#34;&#34;&#34;
    **Description**:
    
    Camera class made to handle webcam footage.
    &#34;&#34;&#34;

    def check_cam(self, NUMBER):
        &#34;&#34;&#34;
        **Description**:
        
        Checks to see if the camera is opened or not.
        
        **Args**:

        `NUMBER` *(int)*: Takes in an integer value defined globally to capture video from indexed camera
        &#34;&#34;&#34;
        cam = cv2.VideoCapture(NUMBER) 
        if cam.isOpened():
            return True
        else:
            return False
       
    def live_feed(self, NUMBER):
        &#34;&#34;&#34;
        **Description**:
        
        Display function to show our webcam footage. No arguments are passed. To display our webcam 
        footage for our current selected camera simply pass display().
        
        **Args**:

        `NUMBER` *(int)*: Takes in an integer value defined globally to capture video from indexed camera
        &#34;&#34;&#34;
        if not self.check_cam(NUMBER):
            tmsg.showinfo(message=&#34;Cannot access camera! Please grant permission and sign in again!&#34;)
            return
        
        #this will be our initialized webcam feed starting from 0 because we only have
        #one webcam currently in service. For each successive webcam we will increment
        #the cv2.VideoCapture size.
        feed = cv2.VideoCapture(NUMBER)
        
        # image that blocks camera feed when it is disabled
        disabledpngpath = r&#39;camdisabled.png&#39;
        disabledpng = cv2.imread(disabledpngpath)
        disabledpng = cv2.resize(disabledpng, (640,480))

        disableWebcam = False
        
        # for motion detection
        frame_count = 0
        previous_frame = None
        
        #this inner function will convert the video to a standard 480p resolution across
        #all webcams that we have. Because most webcams these days on the market are a 
        #minimum of 480p this is a good standard size resolution to have.
        def make_480p(feed):
            feed.set(3,640)
            feed.set(4,480)

        make_480p(feed)
        out = cv2.VideoWriter(desktop+&#34;/Baby Camera Footage/&#34;+today+&#34;/&#34;+filename, cv2.VideoWriter_fourcc(*&#39;MJPG&#39;), 10, (640,480))
        while True:
            ret, display = feed.read()
            
            #will display our current webcam feed with the current date and time in the 
            #center of the window.
            cv2.rectangle(display, (195, 32), (427, 12), (0, 0, 0), -1)

            # time stamp font
            font = cv2.FONT_HERSHEY_SIMPLEX            
#

            img_rgb = display
            # img_rgb = cv2.cvtColor(src=img_brg, code=cv2.COLOR_BGR2RGB)

            if ((frame_count % 2) == 0):

                # 2. Prepare image; grayscale and blur
                prepared_frame = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)
                prepared_frame = cv2.GaussianBlur(src=prepared_frame, ksize=(5,5), sigmaX=0)

                # 3. Set previous frame and continue if there is None
                if (previous_frame is None):
                # First frame; there is no previous one yet
                    previous_frame = prepared_frame
                    continue

                # calculate difference and update previous frame
                diff_frame = cv2.absdiff(src1=previous_frame, src2=prepared_frame)
                previous_frame = prepared_frame

                # 4. Dilute the image a bit to make differences more seeable; more suitable for contour detection
                kernel = np.ones((5, 5))
                diff_frame = cv2.dilate(diff_frame, kernel, 1)

                # 5. Only take different areas that are different enough (&gt;20 / 255)
                # The thresh value was default 20, but I upped it to 50 so it doesn&#39;t catch every single thing that moves.
                thresh_frame = cv2.threshold(src=diff_frame, thresh=50, maxval=255, type=cv2.THRESH_BINARY)[1]

                contours, _ = cv2.findContours(image=thresh_frame, mode=cv2.RETR_EXTERNAL, method=cv2.CHAIN_APPROX_SIMPLE)
                
                # code of highlighting the contour of the detected change
                # removed for adding too much clutter
                # cv2.drawContours(image=img_rgb, contours=contours, contourIdx=-1, color=(0, 255, 0), thickness=2, lineType=cv2.LINE_AA)     

                contours, _ = cv2.findContours(image=thresh_frame, mode=cv2.RETR_EXTERNAL, method=cv2.CHAIN_APPROX_SIMPLE)
                
                # create one bounding box for all detected contours
                # xx/yy represents ending coordinates, not width/height
                (x,y,xx,yy) = (640,480,0,0)
                for contour in contours:
                    if cv2.contourArea(contour) &lt; 50:
                        # too small: skip!
                        continue
                    # find the coordinates for the one bounding box    
                    (xP, yP, wP, hP) = cv2.boundingRect(contour)
                    if (xP+wP &gt; xx):
                        (x,y,xx,yy) = (x,y,xP+wP,yy)
                    if (yP+hP &gt; yy):
                        (x,y,xx,yy) = (x,y,xx,yP+hP)                        
                    if (xP &lt; x):
                        (x,y,xx,yy) = (xP,y,xx,yy)
                    if (yP &lt; y):
                        (x,y,xx,yy) = (x,yP,xx,yy)
                
                # draw one bounding box only if it changes from default
                if ((x,y,xx,yy) != (640,480,0,0)):
                    cv2.rectangle(img=img_rgb, pt1=(x, y), pt2=(xx, yy), color=(0, 255, 0), thickness=2)

#
            cv2.putText(img_rgb ,str(datetime.now()),(210,25), font, .4,(390,255,255),1,cv2.LINE_AA)
            out.write(img_rgb)
            
            
            
            if(disableWebcam):
                cv2.imshow(&#39;Webcam &#39;+str(NUMBER+1), disabledpng)
            else:
                cv2.imshow(&#39;Webcam &#39;+str(NUMBER+1), img_rgb)
            
            #if we want to exit our display before we reach the 100 milliseconds 
            #our waitKey function is set for we can simply press the SPACEBAR and it will
            #stop our program. Ideally, we would want this to be a GUI item to 
            #close our program.
            if cv2.waitKey(100)==32:
                tmsg.showinfo(message=&#34;Recording finished! You can find the recording where your app is located.&#34;)
                break
            
            if cv2.waitKey(20)==27:
                disableWebcam = 1 - disableWebcam            
        #this will release our resource so that another program can use our camera.

        out.release()
        feed.release()
        
        #when we exit the script we can destroy the windows
        cv2.destroyAllWindows()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="CS-555-Team-Project.Cam_Display.Camera.check_cam"><code class="name flex">
<span>def <span class="ident">check_cam</span></span>(<span>self, NUMBER)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Description</strong>:</p>
<p>Checks to see if the camera is opened or not.</p>
<p><strong>Args</strong>:</p>
<p><code>NUMBER</code> <em>(int)</em>: Takes in an integer value defined globally to capture video from indexed camera</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_cam(self, NUMBER):
    &#34;&#34;&#34;
    **Description**:
    
    Checks to see if the camera is opened or not.
    
    **Args**:

    `NUMBER` *(int)*: Takes in an integer value defined globally to capture video from indexed camera
    &#34;&#34;&#34;
    cam = cv2.VideoCapture(NUMBER) 
    if cam.isOpened():
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="CS-555-Team-Project.Cam_Display.Camera.live_feed"><code class="name flex">
<span>def <span class="ident">live_feed</span></span>(<span>self, NUMBER)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Description</strong>:</p>
<p>Display function to show our webcam footage. No arguments are passed. To display our webcam
footage for our current selected camera simply pass display().</p>
<p><strong>Args</strong>:</p>
<p><code>NUMBER</code> <em>(int)</em>: Takes in an integer value defined globally to capture video from indexed camera</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def live_feed(self, NUMBER):
        &#34;&#34;&#34;
        **Description**:
        
        Display function to show our webcam footage. No arguments are passed. To display our webcam 
        footage for our current selected camera simply pass display().
        
        **Args**:

        `NUMBER` *(int)*: Takes in an integer value defined globally to capture video from indexed camera
        &#34;&#34;&#34;
        if not self.check_cam(NUMBER):
            tmsg.showinfo(message=&#34;Cannot access camera! Please grant permission and sign in again!&#34;)
            return
        
        #this will be our initialized webcam feed starting from 0 because we only have
        #one webcam currently in service. For each successive webcam we will increment
        #the cv2.VideoCapture size.
        feed = cv2.VideoCapture(NUMBER)
        
        # image that blocks camera feed when it is disabled
        disabledpngpath = r&#39;camdisabled.png&#39;
        disabledpng = cv2.imread(disabledpngpath)
        disabledpng = cv2.resize(disabledpng, (640,480))

        disableWebcam = False
        
        # for motion detection
        frame_count = 0
        previous_frame = None
        
        #this inner function will convert the video to a standard 480p resolution across
        #all webcams that we have. Because most webcams these days on the market are a 
        #minimum of 480p this is a good standard size resolution to have.
        def make_480p(feed):
            feed.set(3,640)
            feed.set(4,480)

        make_480p(feed)
        out = cv2.VideoWriter(desktop+&#34;/Baby Camera Footage/&#34;+today+&#34;/&#34;+filename, cv2.VideoWriter_fourcc(*&#39;MJPG&#39;), 10, (640,480))
        while True:
            ret, display = feed.read()
            
            #will display our current webcam feed with the current date and time in the 
            #center of the window.
            cv2.rectangle(display, (195, 32), (427, 12), (0, 0, 0), -1)

            # time stamp font
            font = cv2.FONT_HERSHEY_SIMPLEX            
#

            img_rgb = display
            # img_rgb = cv2.cvtColor(src=img_brg, code=cv2.COLOR_BGR2RGB)

            if ((frame_count % 2) == 0):

                # 2. Prepare image; grayscale and blur
                prepared_frame = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)
                prepared_frame = cv2.GaussianBlur(src=prepared_frame, ksize=(5,5), sigmaX=0)

                # 3. Set previous frame and continue if there is None
                if (previous_frame is None):
                # First frame; there is no previous one yet
                    previous_frame = prepared_frame
                    continue

                # calculate difference and update previous frame
                diff_frame = cv2.absdiff(src1=previous_frame, src2=prepared_frame)
                previous_frame = prepared_frame

                # 4. Dilute the image a bit to make differences more seeable; more suitable for contour detection
                kernel = np.ones((5, 5))
                diff_frame = cv2.dilate(diff_frame, kernel, 1)

                # 5. Only take different areas that are different enough (&gt;20 / 255)
                # The thresh value was default 20, but I upped it to 50 so it doesn&#39;t catch every single thing that moves.
                thresh_frame = cv2.threshold(src=diff_frame, thresh=50, maxval=255, type=cv2.THRESH_BINARY)[1]

                contours, _ = cv2.findContours(image=thresh_frame, mode=cv2.RETR_EXTERNAL, method=cv2.CHAIN_APPROX_SIMPLE)
                
                # code of highlighting the contour of the detected change
                # removed for adding too much clutter
                # cv2.drawContours(image=img_rgb, contours=contours, contourIdx=-1, color=(0, 255, 0), thickness=2, lineType=cv2.LINE_AA)     

                contours, _ = cv2.findContours(image=thresh_frame, mode=cv2.RETR_EXTERNAL, method=cv2.CHAIN_APPROX_SIMPLE)
                
                # create one bounding box for all detected contours
                # xx/yy represents ending coordinates, not width/height
                (x,y,xx,yy) = (640,480,0,0)
                for contour in contours:
                    if cv2.contourArea(contour) &lt; 50:
                        # too small: skip!
                        continue
                    # find the coordinates for the one bounding box    
                    (xP, yP, wP, hP) = cv2.boundingRect(contour)
                    if (xP+wP &gt; xx):
                        (x,y,xx,yy) = (x,y,xP+wP,yy)
                    if (yP+hP &gt; yy):
                        (x,y,xx,yy) = (x,y,xx,yP+hP)                        
                    if (xP &lt; x):
                        (x,y,xx,yy) = (xP,y,xx,yy)
                    if (yP &lt; y):
                        (x,y,xx,yy) = (x,yP,xx,yy)
                
                # draw one bounding box only if it changes from default
                if ((x,y,xx,yy) != (640,480,0,0)):
                    cv2.rectangle(img=img_rgb, pt1=(x, y), pt2=(xx, yy), color=(0, 255, 0), thickness=2)

#
            cv2.putText(img_rgb ,str(datetime.now()),(210,25), font, .4,(390,255,255),1,cv2.LINE_AA)
            out.write(img_rgb)
            
            
            
            if(disableWebcam):
                cv2.imshow(&#39;Webcam &#39;+str(NUMBER+1), disabledpng)
            else:
                cv2.imshow(&#39;Webcam &#39;+str(NUMBER+1), img_rgb)
            
            #if we want to exit our display before we reach the 100 milliseconds 
            #our waitKey function is set for we can simply press the SPACEBAR and it will
            #stop our program. Ideally, we would want this to be a GUI item to 
            #close our program.
            if cv2.waitKey(100)==32:
                tmsg.showinfo(message=&#34;Recording finished! You can find the recording where your app is located.&#34;)
                break
            
            if cv2.waitKey(20)==27:
                disableWebcam = 1 - disableWebcam            
        #this will release our resource so that another program can use our camera.

        out.release()
        feed.release()
        
        #when we exit the script we can destroy the windows
        cv2.destroyAllWindows()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="CS-555-Team-Project" href="index.html">CS-555-Team-Project</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="CS-555-Team-Project.Cam_Display.createFolder" href="#CS-555-Team-Project.Cam_Display.createFolder">createFolder</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="CS-555-Team-Project.Cam_Display.Camera" href="#CS-555-Team-Project.Cam_Display.Camera">Camera</a></code></h4>
<ul class="">
<li><code><a title="CS-555-Team-Project.Cam_Display.Camera.check_cam" href="#CS-555-Team-Project.Cam_Display.Camera.check_cam">check_cam</a></code></li>
<li><code><a title="CS-555-Team-Project.Cam_Display.Camera.live_feed" href="#CS-555-Team-Project.Cam_Display.Camera.live_feed">live_feed</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>